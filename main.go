package main // import "4d63.com/embedfiles"

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/gob"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"path/filepath"
	"text/template"

	"4d63.com/embedfiles/tst"
)

const tmpl = `
// Generated by 4d63.com/embedfiles.

package {{.Package}}

{{if .UseTrie}}
import (
	"compress/gzip"
	"encoding/base64"
	"encoding/gob"
	"strings"
)

var {{.FileNamesVar}} []string
var {{.FilesVar}} = make(map[string][]byte)

func init() {
	const raw = ` + "`{{.Raw}}`" + `
	gr, err := gzip.NewReader(base64.NewDecoder(base64.StdEncoding, strings.NewReader(raw)))
	if err != nil {
		panic(err)
	}
	var tr TST
	if err = gob.NewDecoder(gr).Decode(&tr); err != nil {
		panic(err)
	}
	tr.ForEach(func(s string, val []byte) {
		{{.FileNamesVar}} = append({{.FileNamesVar}}, s)
		{{.FilesVar}}[s] = val
	})
}

// TST can be the root, and can be a sub-tree
type TST struct {
	Left  *TST
	Right *TST
	Eq    *TST
	Eqkey byte
	Val   []byte
}

// Child returns the child subtree of the current tree
func (t *TST) Child(c byte) *TST {
	if t.Eq == nil {
		t.Eqkey = c
		t.Eq = &TST{}
		return t.Eq
	} else if c == t.Eqkey {
		return t.Eq
	} else if c < t.Eqkey {
		if t.Left == nil {
			t.Left = &TST{}
		}
		return t.Left.Child(c)
	} else { // c > t.eqkey
		if t.Right == nil {
			t.Right = &TST{}
		}
		return t.Right.Child(c)
	}
}

func (t *TST) ForEach(f func(s string, val []byte)) {
	var prefix []byte
	t.forEach(f, prefix)
}

func (t *TST) forEach(f func(s string, val []byte), prefix []byte) {
	if t.Val != nil {
		f(string(prefix), t.Val)
	}

	if t.Left != nil {
		t.Left.forEach(f, prefix)
	}

	if t.Eq != nil {
		t.Eq.forEach(f, append(prefix, t.Eqkey))
	}

	if t.Right != nil {
		t.Right.forEach(f, prefix)
	}
}
{{else}}
var {{.FileNamesVar}} = []string{ {{range $name, $bytes := .Files}}"{{$name}}",{{end}} }

var {{.FilesVar}} = map[string][]byte{
{{range $name, $bytes := .Files}}
	"{{$name}}": []byte{ {{range $bytes}}{{.}},{{end}} },
{{end}}
}
{{end}}
`

type tmplData struct {
	Package      string
	Files        map[string][]byte
	FileNamesVar string
	FilesVar     string
	Raw          string
	UseTrie      bool
}

func main() {
	out := flag.String("out", "files.go", "output go `file`")
	pkg := flag.String("pkg", "main", "`package` name of the go file")
	filesVar := flag.String("files-var", "files", "name of the generated files slice")
	fileNamesVar := flag.String("file-names-var", "fileNames", "name of the generated file names slice")
	useTrie := flag.Bool("trie", false, "create a Ternary Search Tree")
	verbose := flag.Bool("verbose", false, "")
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Embedfiles embeds files in the paths into a map in a go file.\n\n")
		fmt.Fprintf(os.Stderr, "Usage:\n\n")
		fmt.Fprintf(os.Stderr, "  embedfiles -out=files.go -pkg=main <paths>\n\n")
		fmt.Fprintf(os.Stderr, "Flags:\n\n")
		flag.PrintDefaults()
	}
	flag.Parse()

	inputPaths := flag.Args()

	if len(inputPaths) == 0 {
		flag.Usage()
		return
	}

	f, err := os.Create(*out)
	if err != nil {
		printErr("creating file", err)
		return
	}

	var tr tst.TST
	files := map[string][]byte{}
	for _, inputPath := range inputPaths {
		err = filepath.Walk(inputPath, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return fmt.Errorf("walking: %s", err)
			}

			if info.IsDir() {
				return nil
			}

			if *verbose {
				fmt.Printf("%s ", path)
			}

			contents, err := ioutil.ReadFile(path)
			if err != nil {
				return fmt.Errorf("reading file: %s", err)
			}
			if *verbose {
				fmt.Printf("(%d bytes)\n", len(contents))
			}

			path = filepath.ToSlash(path)
			if *useTrie {
				tr.Set(path, contents)
			} else {
				files[path] = contents
			}
			return nil
		})
		if err != nil {
			printErr("walking", err)
			return
		}
	}
	data := tmplData{
		Package: *pkg, Files: files, FilesVar: *filesVar, FileNamesVar: *fileNamesVar,
		UseTrie: *useTrie,
	}

	if *useTrie {
		var buf bytes.Buffer
		gw, _ := gzip.NewWriterLevel(&buf, gzip.BestSpeed)
		if err := gob.NewEncoder(gw).Encode(tr); err != nil {
			printErr("GOB encode trie", err)
			return
		}
		if err := gw.Close(); err != nil {
			printErr("gzip the GOB", err)
			return
		}
		b := buf.Bytes()
		var outBuf bytes.Buffer
		enc := base64.NewEncoder(base64.StdEncoding, &outBuf)
		for len(b) != 0 {
			n := 54
			if n > len(b) {
				n = len(b)
			}
			if _, err = enc.Write(b[:n]); err != nil {
				printErr("base64 encoding", err)
				return
			}
			b = b[n:]
			outBuf.WriteByte('\n')
		}
		data.Raw = outBuf.String()
	}

	t, err := template.New("").Parse(tmpl)
	if err != nil {
		printErr("parsing template", err)
		return
	}

	var buf bytes.Buffer
	if err = t.Execute(&buf, data); err != nil {
		printErr("generating code", err)
		return
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Fprintf(os.Stderr, buf.String())
		printErr("formatting code", err)
		return
	}

	f.Write(formatted)
	err = f.Close()
	if err != nil {
		printErr("finalizing file", err)
		return
	}
}

func printErr(doing string, err error) {
	fmt.Fprintf(os.Stderr, "Error %s: %s\n", doing, err)
}
